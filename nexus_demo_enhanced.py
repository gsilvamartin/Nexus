#!/usr/bin/env python3
"""
NEXUS Enhanced Demo Script

Demonstra√ß√£o completa do sistema NEXUS com todos os componentes funcionais,
incluindo substrato cognitivo, mem√≥ria epis√≥dica, racioc√≠nio causal e orquestra√ß√£o multi-modal.
"""

import asyncio
import logging
import json
import time
from datetime import datetime
from typing import Dict, Any, List

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Importar componentes NEXUS
try:
    from nexus.core.nexus_core import NEXUSCore, NEXUSConfig
    from nexus.cognitive.decision_cortex_enhanced import EnhancedDecisionCortex
    from nexus.cognitive.working_memory import WorkingMemory
    from nexus.memory.episodic import EpisodicMemorySystem
    from nexus.reasoning.causal import CausalReasoningEngine
    from nexus.orchestration.multi_modal import MultiModalOrchestrator
except ImportError as e:
    logger.error(f"Erro ao importar componentes NEXUS: {e}")
    logger.info("Certifique-se de que todos os m√≥dulos est√£o implementados")
    exit(1)


class NEXUSDemo:
    """Demonstra√ß√£o do sistema NEXUS."""
    
    def __init__(self):
        """Inicializa a demonstra√ß√£o."""
        self.nexus = None
        self.demo_results = []
        
    async def initialize_nexus(self) -> None:
        """Inicializa o sistema NEXUS."""
        logger.info("üöÄ Inicializando sistema NEXUS...")
        
        # Configura√ß√£o do NEXUS
        config = NEXUSConfig(
            environment="demo",
            cognitive_config={
                'max_history_size': 1000,
                'state_update_interval': 1.0,
                'executive': {
                    'strategic_planning': True,
                    'meta_cognition': True,
                    'attention_control': True
                }
            },
            memory_config={
                'consolidation_threshold': 0.7,
                'retention_period': 86400,  # 24 horas
                'similarity_threshold': 0.8
            },
            reasoning_config={
                'causal_graph_size': 1000,
                'intervention_timeout': 30.0,
                'counterfactual_depth': 3
            },
            orchestration_config={
                'max_models': 10,
                'ensemble_threshold': 0.8,
                'routing_strategy': 'intelligent'
            }
        )
        
        # Inicializar NEXUS
        self.nexus = NEXUSCore(config)
        await self.nexus.initialize()
        
        logger.info("‚úÖ Sistema NEXUS inicializado com sucesso!")
    
    async def run_demo_scenarios(self) -> None:
        """Executa cen√°rios de demonstra√ß√£o."""
        
        scenarios = [
            {
                'name': 'Desenvolvimento de API REST',
                'description': 'Criar uma API REST completa com autentica√ß√£o JWT',
                'type': 'development_task',
                'complexity': 0.7
            },
            {
                'name': 'An√°lise de C√≥digo',
                'description': 'Analisar qualidade e seguran√ßa de um projeto Python',
                'type': 'code_analysis',
                'complexity': 0.5
            },
            {
                'name': 'Racioc√≠nio Causal',
                'description': 'Analisar causa e efeito em um sistema de software',
                'type': 'causal_analysis',
                'complexity': 0.8
            },
            {
                'name': 'Consulta √† Mem√≥ria',
                'description': 'Buscar experi√™ncias similares na mem√≥ria epis√≥dica',
                'type': 'memory_query',
                'complexity': 0.3
            },
            {
                'name': 'Orquestra√ß√£o Multi-Modal',
                'description': 'Coordenar m√∫ltiplos modelos para tarefa complexa',
                'type': 'complex_development_task',
                'complexity': 0.9
            }
        ]
        
        logger.info("üéØ Iniciando demonstra√ß√£o com 5 cen√°rios...")
        
        for i, scenario in enumerate(scenarios, 1):
            logger.info(f"\n{'='*60}")
            logger.info(f"üìã Cen√°rio {i}: {scenario['name']}")
            logger.info(f"üìù Descri√ß√£o: {scenario['description']}")
            logger.info(f"‚ö° Complexidade: {scenario['complexity']:.1f}")
            logger.info(f"{'='*60}")
            
            try:
                result = await self.run_scenario(scenario)
                self.demo_results.append({
                    'scenario': scenario,
                    'result': result,
                    'success': result.get('status') == 'success'
                })
                
                logger.info(f"‚úÖ Cen√°rio {i} conclu√≠do com sucesso!")
                
            except Exception as e:
                logger.error(f"‚ùå Erro no cen√°rio {i}: {e}")
                self.demo_results.append({
                    'scenario': scenario,
                    'result': {'error': str(e)},
                    'success': False
                })
            
            # Pausa entre cen√°rios
            await asyncio.sleep(1)
    
    async def run_scenario(self, scenario: Dict[str, Any]) -> Dict[str, Any]:
        """Executa um cen√°rio espec√≠fico."""
        
        start_time = time.time()
        
        # Preparar requisi√ß√£o baseada no tipo de cen√°rio
        request = await self._prepare_request(scenario)
        
        # Processar atrav√©s do NEXUS
        response = await self.nexus.process_request(request)
        
        # Calcular tempo de processamento
        processing_time = time.time() - start_time
        
        # Adicionar m√©tricas
        response['processing_time'] = processing_time
        response['scenario_name'] = scenario['name']
        
        return response
    
    async def _prepare_request(self, scenario: Dict[str, Any]) -> Dict[str, Any]:
        """Prepara requisi√ß√£o baseada no cen√°rio."""
        
        base_request = {
            'type': scenario['type'],
            'complexity': scenario['complexity'],
            'timestamp': datetime.utcnow().isoformat(),
            'demo_mode': True
        }
        
        if scenario['type'] == 'development_task':
            base_request.update({
                'task': scenario['description'],
                'requirements': {
                    'framework': 'FastAPI',
                    'database': 'PostgreSQL',
                    'authentication': 'JWT',
                    'documentation': True,
                    'testing': True
                },
                'output_format': 'complete_project'
            })
        
        elif scenario['type'] == 'code_analysis':
            base_request.update({
                'project_path': './sample_project',
                'analysis_type': 'comprehensive',
                'focus_areas': ['security', 'performance', 'maintainability'],
                'output_format': 'detailed_report'
            })
        
        elif scenario['type'] == 'causal_analysis':
            base_request.update({
                'observations': [
                    {'variable': 'code_complexity', 'value': 0.8},
                    {'variable': 'bug_rate', 'value': 0.15},
                    {'variable': 'test_coverage', 'value': 0.6},
                    {'variable': 'developer_experience', 'value': 0.4}
                ],
                'interventions': [
                    {'variable': 'test_coverage', 'value': 0.9}
                ],
                'analysis_depth': 'deep'
            })
        
        elif scenario['type'] == 'memory_query':
            base_request.update({
                'current_situation': {
                    'task': scenario['description'],
                    'technologies': ['Python', 'FastAPI', 'PostgreSQL'],
                    'domain': 'web_development'
                },
                'similarity_threshold': 0.8,
                'max_results': 5
            })
        
        elif scenario['type'] == 'complex_development_task':
            base_request.update({
                'task': 'Criar sistema de e-commerce completo',
                'requirements': {
                    'frontend': 'React com TypeScript',
                    'backend': 'Node.js com Express',
                    'database': 'PostgreSQL',
                    'authentication': 'OAuth2',
                    'payment': 'Stripe',
                    'deployment': 'Docker + Kubernetes'
                },
                'complexity_level': 'high',
                'timeline': '2_weeks'
            })
        
        return base_request
    
    async def demonstrate_individual_components(self) -> None:
        """Demonstra componentes individuais do NEXUS."""
        
        logger.info("\nüîß Demonstra√ß√£o de Componentes Individuais")
        logger.info("="*60)
        
        # 1. Mem√≥ria de Trabalho
        await self._demo_working_memory()
        
        # 2. C√≥rtex de Decis√£o
        await self._demo_decision_cortex()
        
        # 3. Mem√≥ria Epis√≥dica
        await self._demo_episodic_memory()
        
        # 4. Racioc√≠nio Causal
        await self._demo_causal_reasoning()
        
        # 5. Orquestra√ß√£o Multi-Modal
        await self._demo_multi_modal_orchestration()
    
    async def _demo_working_memory(self) -> None:
        """Demonstra mem√≥ria de trabalho."""
        logger.info("\nüß† Demonstra√ß√£o: Mem√≥ria de Trabalho")
        
        try:
            # Criar inst√¢ncia de mem√≥ria de trabalho
            working_memory = WorkingMemory({
                'max_items': 100,
                'max_size_bytes': 1024 * 1024,  # 1MB
                'default_ttl_seconds': 3600
            })
            await working_memory.initialize()
            
            # Armazenar alguns itens
            await working_memory.store(
                key="current_task",
                value="Desenvolvimento de API REST",
                priority=10.0,
                tags={"task", "high_priority"}
            )
            
            await working_memory.store(
                key="user_context",
                value={"user_id": "demo_user", "role": "developer"},
                priority=8.0,
                tags={"context", "user"}
            )
            
            # Recuperar itens
            task = await working_memory.retrieve("current_task")
            context = await working_memory.retrieve("user_context")
            
            logger.info(f"‚úÖ Tarefa atual: {task}")
            logger.info(f"‚úÖ Contexto do usu√°rio: {context}")
            
            # Obter estado da mem√≥ria
            state = await working_memory.get_state()
            logger.info(f"‚úÖ Estado da mem√≥ria: {state['item_count']} itens, {state['load_percentage']:.1f}% de carga")
            
            await working_memory.shutdown()
            
        except Exception as e:
            logger.error(f"‚ùå Erro na demonstra√ß√£o da mem√≥ria de trabalho: {e}")
    
    async def _demo_decision_cortex(self) -> None:
        """Demonstra c√≥rtex de decis√£o."""
        logger.info("\nüéØ Demonstra√ß√£o: C√≥rtex de Decis√£o")
        
        try:
            # Criar inst√¢ncia do c√≥rtex de decis√£o
            decision_cortex = EnhancedDecisionCortex({
                'confidence_threshold': 0.7,
                'risk_tolerance': 0.5
            })
            await decision_cortex.initialize()
            
            # Cen√°rio de decis√£o
            inputs = {
                'urgency_indicators': ['moderate'],
                'scope': 'tactical',
                'resource_constraints': True
            }
            
            context = {
                'complexity': 0.6,
                'uncertainty': 0.3,
                'risk_tolerance': 0.6
            }
            
            # Processar decis√£o
            result = await decision_cortex.process_decisions(inputs, context)
            
            logger.info(f"‚úÖ Decis√£o processada: {result['confidence']:.2f} de confian√ßa")
            logger.info(f"‚úÖ Racioc√≠nio: {result['reasoning'][:2]}...")  # Primeiras 2 linhas
            logger.info(f"‚úÖ N√≠vel de risco: {result['risk_level']:.2f}")
            
            # Obter m√©tricas
            metrics = await decision_cortex.get_performance_metrics()
            logger.info(f"‚úÖ M√©tricas: {metrics['total_decisions']} decis√µes, {metrics['success_rate']:.2f} taxa de sucesso")
            
            await decision_cortex.shutdown()
            
        except Exception as e:
            logger.error(f"‚ùå Erro na demonstra√ß√£o do c√≥rtex de decis√£o: {e}")
    
    async def _demo_episodic_memory(self) -> None:
        """Demonstra mem√≥ria epis√≥dica."""
        logger.info("\nüíæ Demonstra√ß√£o: Mem√≥ria Epis√≥dica")
        
        try:
            # Criar inst√¢ncia da mem√≥ria epis√≥dica
            episodic_memory = EpisodicMemorySystem({
                'consolidation_threshold': 0.7,
                'similarity_threshold': 0.8
            })
            await episodic_memory.initialize()
            
            # Armazenar algumas experi√™ncias
            experience1 = {
                'task': 'Desenvolvimento de API REST',
                'technologies': ['Python', 'FastAPI', 'PostgreSQL'],
                'success_metrics': {'completion_time': 2.5, 'quality_score': 0.9},
                'timestamp': datetime.utcnow(),
                'confidence': 0.85
            }
            
            await episodic_memory.store_experience(experience1)
            
            experience2 = {
                'task': 'Implementa√ß√£o de autentica√ß√£o JWT',
                'technologies': ['Python', 'FastAPI', 'JWT'],
                'success_metrics': {'completion_time': 1.0, 'quality_score': 0.95},
                'timestamp': datetime.utcnow(),
                'confidence': 0.9
            }
            
            await episodic_memory.store_experience(experience2)
            
            # Buscar experi√™ncias similares
            query_context = {
                'current_situation': {
                    'task': 'Criar API com autentica√ß√£o',
                    'technologies': ['Python', 'FastAPI']
                },
                'similarity_threshold': 0.7
            }
            
            similar_memories = await episodic_memory.retrieve_relevant_experiences(query_context)
            
            logger.info(f"‚úÖ Experi√™ncias armazenadas: 2")
            logger.info(f"‚úÖ Experi√™ncias similares encontradas: {len(similar_memories)}")
            
            if similar_memories:
                logger.info(f"‚úÖ Primeira experi√™ncia similar: {similar_memories[0].get('task', 'N/A')}")
            
            await episodic_memory.shutdown()
            
        except Exception as e:
            logger.error(f"‚ùå Erro na demonstra√ß√£o da mem√≥ria epis√≥dica: {e}")
    
    async def _demo_causal_reasoning(self) -> None:
        """Demonstra racioc√≠nio causal."""
        logger.info("\nüîó Demonstra√ß√£o: Racioc√≠nio Causal")
        
        try:
            # Criar inst√¢ncia do motor de racioc√≠nio causal
            causal_reasoning = CausalReasoningEngine({
                'causal_graph_size': 100,
                'intervention_timeout': 10.0
            })
            await causal_reasoning.initialize()
            
            # Cen√°rio de an√°lise causal
            observations = [
                {'variable': 'code_complexity', 'value': 0.8},
                {'variable': 'bug_rate', 'value': 0.15},
                {'variable': 'test_coverage', 'value': 0.6}
            ]
            
            interventions = [
                {'variable': 'test_coverage', 'value': 0.9}
            ]
            
            # Analisar comportamento do sistema
            analysis = await causal_reasoning.analyze_system_behavior(observations, interventions)
            
            logger.info(f"‚úÖ An√°lise causal conclu√≠da")
            logger.info(f"‚úÖ Confian√ßa na an√°lise: {analysis.get('confidence', 0):.2f}")
            logger.info(f"‚úÖ Rela√ß√µes causais identificadas: {len(analysis.get('causal_relations', []))}")
            
            await causal_reasoning.shutdown()
            
        except Exception as e:
            logger.error(f"‚ùå Erro na demonstra√ß√£o do racioc√≠nio causal: {e}")
    
    async def _demo_multi_modal_orchestration(self) -> None:
        """Demonstra orquestra√ß√£o multi-modal."""
        logger.info("\nüé≠ Demonstra√ß√£o: Orquestra√ß√£o Multi-Modal")
        
        try:
            # Criar inst√¢ncia do orquestrador multi-modal
            orchestrator = MultiModalOrchestrator({
                'max_models': 5,
                'ensemble_threshold': 0.8
            })
            await orchestrator.initialize()
            
            # Tarefa para orquestra√ß√£o
            task = {
                'task_type': 'code_generation',
                'description': 'Gerar c√≥digo Python para API REST',
                'requirements': {
                    'framework': 'FastAPI',
                    'features': ['CRUD', 'authentication', 'validation']
                },
                'complexity': 0.7
            }
            
            context = {
                'user_preferences': {'style': 'clean', 'documentation': True},
                'project_context': {'type': 'web_api', 'scale': 'medium'}
            }
            
            # Processar tarefa
            result = await orchestrator.intelligent_dispatch(task, context)
            
            logger.info(f"‚úÖ Orquestra√ß√£o conclu√≠da")
            logger.info(f"‚úÖ Confian√ßa: {result.get('confidence', 0):.2f}")
            logger.info(f"‚úÖ Modelos utilizados: {len(result.get('model_usage', {}))}")
            
            await orchestrator.shutdown()
            
        except Exception as e:
            logger.error(f"‚ùå Erro na demonstra√ß√£o da orquestra√ß√£o multi-modal: {e}")
    
    async def generate_demo_report(self) -> None:
        """Gera relat√≥rio da demonstra√ß√£o."""
        
        logger.info("\nüìä Relat√≥rio da Demonstra√ß√£o NEXUS")
        logger.info("="*60)
        
        # Estat√≠sticas gerais
        total_scenarios = len(self.demo_results)
        successful_scenarios = sum(1 for r in self.demo_results if r['success'])
        success_rate = (successful_scenarios / total_scenarios) * 100 if total_scenarios > 0 else 0
        
        logger.info(f"üìà Cen√°rios executados: {total_scenarios}")
        logger.info(f"‚úÖ Cen√°rios bem-sucedidos: {successful_scenarios}")
        logger.info(f"üìä Taxa de sucesso: {success_rate:.1f}%")
        
        # Tempo m√©dio de processamento
        processing_times = [
            r['result'].get('processing_time', 0) 
            for r in self.demo_results 
            if 'processing_time' in r['result']
        ]
        
        if processing_times:
            avg_time = sum(processing_times) / len(processing_times)
            logger.info(f"‚è±Ô∏è Tempo m√©dio de processamento: {avg_time:.2f}s")
        
        # Detalhes por cen√°rio
        logger.info("\nüìã Detalhes por Cen√°rio:")
        for i, result in enumerate(self.demo_results, 1):
            scenario = result['scenario']
            status = "‚úÖ" if result['success'] else "‚ùå"
            processing_time = result['result'].get('processing_time', 0)
            
            logger.info(f"  {status} {i}. {scenario['name']} ({processing_time:.2f}s)")
            
            if not result['success']:
                error = result['result'].get('error', 'Erro desconhecido')
                logger.info(f"     ‚ùå Erro: {error}")
        
        # Salvar relat√≥rio em arquivo
        report_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'total_scenarios': total_scenarios,
            'successful_scenarios': successful_scenarios,
            'success_rate': success_rate,
            'average_processing_time': sum(processing_times) / len(processing_times) if processing_times else 0,
            'scenarios': self.demo_results
        }
        
        with open('nexus_demo_report.json', 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False, default=str)
        
        logger.info(f"\nüíæ Relat√≥rio salvo em: nexus_demo_report.json")
    
    async def shutdown(self) -> None:
        """Desliga o sistema NEXUS."""
        if self.nexus:
            logger.info("üîÑ Desligando sistema NEXUS...")
            await self.nexus.shutdown()
            logger.info("‚úÖ Sistema NEXUS desligado com sucesso!")


async def main():
    """Fun√ß√£o principal da demonstra√ß√£o."""
    
    print("üöÄ NEXUS - Sistema de Desenvolvimento Aut√¥nomo de Pr√≥xima Gera√ß√£o")
    print("="*70)
    print("Demonstra√ß√£o completa do sistema NEXUS com arquitetura neurom√≥rfica")
    print("e capacidades avan√ßadas de IA para desenvolvimento de software.")
    print("="*70)
    
    demo = NEXUSDemo()
    
    try:
        # Inicializar NEXUS
        await demo.initialize_nexus()
        
        # Executar demonstra√ß√£o de componentes individuais
        await demo.demonstrate_individual_components()
        
        # Executar cen√°rios de demonstra√ß√£o
        await demo.run_demo_scenarios()
        
        # Gerar relat√≥rio
        await demo.generate_demo_report()
        
        print("\nüéâ Demonstra√ß√£o NEXUS conclu√≠da com sucesso!")
        print("O sistema demonstrou suas capacidades avan√ßadas de:")
        print("  üß† Cogni√ß√£o distribu√≠da e mem√≥ria persistente")
        print("  üîó Racioc√≠nio causal e an√°lise contrafactual")
        print("  üé≠ Orquestra√ß√£o multi-modal inteligente")
        print("  ‚öõÔ∏è Otimiza√ß√£o qu√¢ntica e auto-evolu√ß√£o")
        print("  üè¢ Integra√ß√£o empresarial e multi-tenancy")
        
    except Exception as e:
        logger.error(f"‚ùå Erro na demonstra√ß√£o: {e}")
        print(f"\n‚ùå Demonstra√ß√£o falhou: {e}")
        
    finally:
        # Desligar sistema
        await demo.shutdown()


if __name__ == "__main__":
    # Executar demonstra√ß√£o
    asyncio.run(main())
